{"links": {"self": {"href": "data/repositories/osrf/robocup3ds/pullrequests/6/comments/7985066.json"}, "html": {"href": "#!/osrf/robocup3ds/pull-requests/6/_/diff#comment-7985066"}}, "parent": {"id": 7977922, "links": {"self": {"href": "data/repositories/osrf/robocup3ds/pullrequests/6/comments/7977922.json"}, "html": {"href": "#!/osrf/robocup3ds/pull-requests/6/_/diff#comment-7977922"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 6, "links": {"self": {"href": "data/repositories/osrf/robocup3ds/pullrequests/6.json"}, "html": {"href": "#!/osrf/robocup3ds/pull-requests/6"}}, "title": "TCP server"}, "content": {"raw": "Hi Nima, \n\nWe took a look at how the agents are sending out messages to the server and it is in the following format:\n\n```\n#!c++\n\nx\"(...)...(...)\"\n\nHere is an actual example:\n348\"(beam -14.5 0 0)(he1 0.259807)(he2 -2.8381)(lae1 -3.02396)(lae2 0.58819)(lae3 -2.65155)(lae4 -0.56844)(rae1 -3.02396)(rae2 -0.548179)(rae3 2.65155)(rae4 0.56844)(lle1 0)(lle2 0.0481245)(lle3 1.40374)(lle4 -2.43462)(lle5 1.52675)(lle6 0.0722854)(lle7 0)(rle1 0)(rle2 0.0487521)(rle3 1.29475)(rle4 -2.20312)(rle5 1.40424)(rle6 0.0716699)(rle7 0)(syn)\"\n```\n\nx is the length of all the s-expressions that come after it. So if the s-expressions after it is 348 characters long, then x is equal to 348. Furthermore, x is an unsigned int that is in network endian format. You have to first convert x to unsigned int, then call ntohl(x) to convert it to the proper host endian format. It is important to note that x is not a valid ascii character (it is sizeof(unsigned int) or usually 4 bytes long), but the rest of the message is. \n\nFor the parser, it should have the following public function which the server can call: \n\n```\n#!c++\n\nbool Parser::parse(char* _msg, size_t _len);\n```\nThe server will provide a char array, as well as the number of bytes that is contained in it. Parse() will examine the first sizeof(unsigned int) bytes of _msg, extract x from it, and if _len == x + sizeof(unsigned int), then it should use the s-expression library to parse all the remaining bytes. The Parser class should also have some member data structures to hold the information after they are parsed. For example, there should be a map<std::string, double> that holds the name and velocity information for the hinge joints of the nao. The function returns true when parsing is successful and all the member data structures are filled.", "markup": "markdown", "html": "<p>Hi Nima, </p>\n<p>We took a look at how the agents are sending out messages to the server and it is in the following format:</p>\n<div class=\"codehilite language-c++\"><pre><span></span><span class=\"n\">x</span><span class=\"s\">&quot;(...)...(...)&quot;</span>\n\n<span class=\"n\">Here</span> <span class=\"n\">is</span> <span class=\"n\">an</span> <span class=\"n\">actual</span> <span class=\"nl\">example</span><span class=\"p\">:</span>\n<span class=\"mi\">348</span><span class=\"s\">&quot;(beam -14.5 0 0)(he1 0.259807)(he2 -2.8381)(lae1 -3.02396)(lae2 0.58819)(lae3 -2.65155)(lae4 -0.56844)(rae1 -3.02396)(rae2 -0.548179)(rae3 2.65155)(rae4 0.56844)(lle1 0)(lle2 0.0481245)(lle3 1.40374)(lle4 -2.43462)(lle5 1.52675)(lle6 0.0722854)(lle7 0)(rle1 0)(rle2 0.0487521)(rle3 1.29475)(rle4 -2.20312)(rle5 1.40424)(rle6 0.0716699)(rle7 0)(syn)&quot;</span>\n</pre></div>\n\n\n<p>x is the length of all the s-expressions that come after it. So if the s-expressions after it is 348 characters long, then x is equal to 348. Furthermore, x is an unsigned int that is in network endian format. You have to first convert x to unsigned int, then call ntohl(x) to convert it to the proper host endian format. It is important to note that x is not a valid ascii character (it is sizeof(unsigned int) or usually 4 bytes long), but the rest of the message is. </p>\n<p>For the parser, it should have the following public function which the server can call: </p>\n<div class=\"codehilite language-c++\"><pre><span></span><span class=\"kt\">bool</span> <span class=\"n\">Parser</span><span class=\"o\">::</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"kt\">char</span><span class=\"o\">*</span> <span class=\"n\">_msg</span><span class=\"p\">,</span> <span class=\"kt\">size_t</span> <span class=\"n\">_len</span><span class=\"p\">);</span>\n</pre></div>\n\n\n<p>The server will provide a char array, as well as the number of bytes that is contained in it. Parse() will examine the first sizeof(unsigned int) bytes of _msg, extract x from it, and if _len == x + sizeof(unsigned int), then it should use the s-expression library to parse all the remaining bytes. The Parser class should also have some member data structures to hold the information after they are parsed. For example, there should be a map&lt;std::string, double&gt; that holds the name and velocity information for the hinge joints of the nao. The function returns true when parsing is successful and all the member data structures are filled.</p>", "type": "rendered"}, "created_on": "2015-07-02T18:06:30.041425+00:00", "user": {"display_name": "jasonzliang NA", "uuid": "{663c75f1-dde2-425c-aa25-68ad2f4eb5ec}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B663c75f1-dde2-425c-aa25-68ad2f4eb5ec%7D"}, "html": {"href": "https://bitbucket.org/%7B663c75f1-dde2-425c-aa25-68ad2f4eb5ec%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:4f6d7230-9817-448e-8b0d-98cb3dd0821c/5b9c099e-6241-49a1-ba1d-fabcca24c6c3/128"}}, "nickname": "jasonzliang", "type": "user", "account_id": "557058:4f6d7230-9817-448e-8b0d-98cb3dd0821c"}, "updated_on": "2015-07-02T18:42:18.034421+00:00", "type": "pullrequest_comment", "id": 7985066}